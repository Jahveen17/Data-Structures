package cs2321;

import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;

import net.datastructures.*;

/**
 * 
 * @author Javen Zamojcin
 * 
 * Data Structures - CS2321
 * 
 * Assignment #5: Huffman Coding
 *
 */

/*
 * The format of the compressed file includes 3 continuously parts:
 *  1. prefix tree in bit stream
 *  2. length of the original file using 4 bytes
 *  3. data coded with Huffman coding. 
 * 
 * Encoding prefix tree bit stream: 
 *   if the node is external, output 0, followed by the letter
 *   if the node is internal, output 1, followed by 
 *  		the bit stream of left subtree, then the bit stream of right subtree. 
 */
public class Huffman {
	
	String[] codetable;
	String outputString;
	
	/**
	 * 
	 * Compress file using Huffman code. 
	 *
	 * @param inputFile  The original data file
	 * @param outputFile  The compressed data file that should be generated. 
	 * @return the length of the data encoded with Huffman Code, don't include data for the prefix tree and length of the original file. 
	 * @throws IOException if inputFile or outputFile does not exist
	 */
	@TimeComplexity("O(n^2)")
	public int compress(String inputFile, String outputFile) {
		
		FileReader inputReader;
		LinkedBinaryTree<Character> tree = null;
		char[] inputArray = null;
		String inputString = "";
		outputString = "";
		int inputCounter = 0;
		int length = 0;
		codetable = new String[255];
		
		try {
			
			inputReader = new FileReader(inputFile);
			
			while ( (inputCounter = inputReader.read()) != -1 ) {
				
				inputString += (char) inputCounter;
				length++;
				
			}
			
			//Build code table
			inputArray = inputString.toCharArray();
			tree = buildPrefixTree(inputArray);
			buildCode(tree.root(), "", tree);
			
			//Build outputString
			writePrefixTree(tree.root(), tree);
			writeLength(length);
			writeCode(inputArray);
			
			System.out.println(outputString);
			
			inputReader.close();
			
		} catch (IOException e) {
			e.printStackTrace();
		}
		
		try {
			
			DataOutputStream outputStream = new DataOutputStream(new FileOutputStream(outputFile));
			
			int counter = 0;

			for ( int i = 0; i < outputString.length() / 8; i++ ) {
				
				outputStream.write(Integer.parseInt(outputString.substring(counter, counter + 8), 2));
				counter += 8;

			}
			
			outputStream.close();
			
		} catch (IOException e) {
			e.printStackTrace();
		}
		
		return codeLength(inputArray);
	}
	
	
	/**
	 * Decode the compressed data file back to the original data file. 
	 * 
	 * @param inputFile : the compressed file
	 * @param outputFile : the file that should be generated by the decode function using ascii code. 
	 * @throws IOException if inputFile or outputFile does not exist
	 */
	
	@TimeComplexity("O(n^2)")
	public void decode(String inputFile, String outputFile) {
		
		DataInputStream inputStream;
		DataInputStream inputStream2;
		FileWriter outputWriter;
		LinkedBinaryTree<Character> tree = null;
		outputString = "";
		
		try {
			
			outputWriter = new FileWriter(outputFile);
			inputStream = new DataInputStream( new FileInputStream(inputFile));
			inputStream2 = new DataInputStream ( new FileInputStream(outputFile));
			int inputFileLength = 0;
			
			while ( inputStream.read() != -1 ) {
				inputFileLength++;
			}
			
			inputStream = new DataInputStream( new FileInputStream(inputFile));
			
			for ( int i = 0; i < inputFileLength; i++ )
				outputString += String.format("%8s", Integer.toBinaryString(inputStream.readByte() & 0xFF)).replace(' ', '0');

			outputWriter.write(outputString);
			outputWriter.close();
			
			tree = readPrefixTree(inputStream2);

			outputString = "";
			
			String slength = "";
			for(int i = 0; i < 32; i++)
				slength += (char)inputStream2.read();
			int length = Integer.parseInt(slength, 2);
			
			for ( int i = 0; i < length; i++ ) {
				
				Position<Character> e = tree.root();
				
				while ( tree.isInternal(e) ) {
					
					int temp = inputStream2.read();
					
					if ( temp == 48){
						
						e = tree.left(e);
						
					} else {
						
						e = tree.right(e);
						
					}
				}
				
				outputString += e.getElement();
			}
			
			outputWriter = new FileWriter(outputFile);
			outputWriter.write(outputString);
			outputWriter.close();
			
		} catch (IOException e) {
			e.printStackTrace();
		}	
	}
	
	//Compressing
	private void writeLength(int length) {
		
		String x = "";
		String y = charToBinary( (char) length );
		
		for ( int i = 0; i < (32 - y.length()); i++ ) {
			
			x += "0";
			
		}
		
		x += y;
		
		outputString += x;
	}
	
	//Compressing
	private String charToBinary( char a ) {
		
		String x = Integer.toBinaryString( (int) a );
		
		if ( x.length() < 8 ) {
			
			String temp = x.substring(0, x.length());
			
			for ( int i = 0; i <= ( 8 - x.length()); i++) {
				
				x = "0" + temp;
				temp = x;
				
			}
		}

		return x;
	}
	
	//Compressing
	private void writePrefixTree( Position<Character> e, LinkedBinaryTree<Character> tree ) {
		
		if ( tree.isExternal(e) ) {
			
			outputString += "0";
			outputString += charToBinary(e.getElement());
			
		} else {
			
			outputString += "1";
			writePrefixTree(tree.left(e), tree);
			writePrefixTree(tree.right(e), tree);
			
		}
	}
	
	//Compressing
	private int codeLength(char[] a) {
		
		String x = "";
		
		for ( int i = 0; i < a.length; i++ ) {
			
			if ( codetable[a[i]] != null )
				x += codetable[a[i]];
		}
		
		return x.length();
	}
	
	//Compressing
	private void writeCode(char[] a) {
		
		String x = "";
		
		for ( int i = 0; i < a.length; i++ ) {
			
			if ( codetable[a[i]] != null )
				x += codetable[a[i]];
			
		}
		outputString += x;
		
		//Padding
		if ( (outputString.length() % 8) != 0 ) {
			
			for ( int i = 0; i < outputString.length() % 8; i++ ) {
				outputString += "0";
			}
			
		}
	}
	
	//Compressing
	private LinkedBinaryTree<Character> buildPrefixTree(char[] A) {
		
		HeapPQ<Integer, LinkedBinaryTree<Character>> pq = new HeapPQ<>();
		Integer[] freq = new Integer[255];
		
		for ( int i = 0; i < freq.length; i++ ) {
			
			freq[i] = 0;
		}
		
		for ( int i = 0; i < A.length; i++ ) {
			
			freq[A[i]]++;
		}
		
		for ( int i = 0; i < 255; i++ ) {
			
			if (freq[i] > 0) {
				
				LinkedBinaryTree<Character> temp = new LinkedBinaryTree<>();
				temp.addRoot( (char) i);
				pq.insert(freq[i], temp);
				
			}
		}
		
		while ( pq.size() > 1 ) {
			
			Entry<Integer, LinkedBinaryTree<Character>> e1 = pq.removeMin();
			Entry<Integer, LinkedBinaryTree<Character>> e2 = pq.removeMin();
			
			Integer combinedFrequency = e1.getKey() + e2.getKey();
			
			LinkedBinaryTree<Character> tree = new LinkedBinaryTree<>();
			tree.addRoot(' ');
			tree.attach(tree.root(), e1.getValue(), e2.getValue());
			pq.insert(combinedFrequency, tree);
			
		}
		
		return pq.min().getValue();
	}
	
	//Compressing
	private void buildCode( Position<Character> e, String code, LinkedBinaryTree<Character> tree ) {
		
		if ( tree.isExternal(e) ) {
			
			codetable[e.getElement()] = code;
			
		} else {
			
			buildCode(tree.left(e), code + "0", tree);
			buildCode(tree.right(e), code + "1", tree);
			
		}
	}
	
	//Decoding
	private LinkedBinaryTree<Character> readPrefixTree(DataInputStream inputStream) throws IOException {
		
		LinkedBinaryTree<Character> tree1 = new LinkedBinaryTree<>();
		LinkedBinaryTree<Character> tree2;
		LinkedBinaryTree<Character> tree3;
		String s = "";
		
		int buffer = inputStream.read();

		if ( buffer == 48 ) {

			for ( int i = 0; i < 8; i++ ) {
				s += (char) inputStream.read();
			}
			
			int letter = Integer.parseInt(s, 2);
			
			tree1.addRoot((char) letter);
			return tree1;

		} else {

			tree2 = readPrefixTree(inputStream);
			tree3 = readPrefixTree(inputStream);
			tree1.addRoot(' ');
			tree1.attach(tree1.root(), tree2, tree3);
			return tree1;

		}
	}

	
	public static void main(String [ ] args) throws IOException {
		
		Huffman huffman = new Huffman();
		int length = 0;
		
		length = huffman.compress("testinput.txt", "testoutput.txt");
		System.out.println("length is " + length);
		
//		// decode your newly created compress file. The generated file "ab.txt.decoded" should have same content as "ab.txt"
		huffman.decode("testoutput.txt", "testoutput2");
	
		// decode the previous correctly compressed file by instructor.  The generated file "ab.txt.decoded" should have content as "ab.txt"
		//huffman.decode("testoutput.txt", "ab.txt");


		// You may perform the above same testing for other files, like abra.txt, gogo.txt, tinytinyTable.txt
		
	}
}
